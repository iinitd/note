# 操作系统

​ 进程线程通信 [https://blog.csdn.net/u012050154/article/details/52245396](https://blog.csdn.net/u012050154/article/details/52245396) 内存放堆栈 变量逃逸 [https://www.cnblogs.com/itbsl/p/10476674.html](https://www.cnblogs.com/itbsl/p/10476674.html) linux 常用命令有哪些、分别举例。 查询 3306 端口占用情况的 linux 指令如何写。 linux 中查看某个 java 进行的进程号 pid、如何操作呢。 进程通信方式。 进程、线程、协程。 进程调度算法。 Liunx下的 I/O 模型。 用户态、内核态。 如何减少内核态到用户态的拷贝（mmap）。 常用的命令。 查看日志。

浅谈如何提高服务器并发处理能力

### [https://www.jianshu.com/p/128352841aab](https://www.jianshu.com/p/128352841aab)

## 计算机基础

设计模式，聊了10多种然后被面试官叫停了 mysql查询两个表中的数据，写了两种方式说了性能有差异 数据库优化 数据库优化：说完索引，索引原理；说完分库，主从数据库数据一致性算法，主从延迟问题；mysql架构，mysql引擎区别 接触过redis？说说redis雪崩问题 设计模式 docker相关的东西（在公司写了n多docker的脚本和file与yml了） 愿意写java吗，我说没问题，crud还是会的，然后被问了几句sql 注册登录咋做的，确保安全的吗，聊了聊用到的加密机制和原理 git 如何忽略改动的文件（不是ignore） git stash什么情况下不能用 发布者订阅者和观察者模式 pubsub中间有一个 各有什么实际场景 git 如何忽略改动的文件（不是ignore） 本地修改不提交到远程仓库 git update-index –assume-unchanged index.jsp 取消本地忽略 git update-index –no-assume-unchanged index.jsp 查看本地仓库哪些文件被加入忽略列表 git ls-files -v git stash什么情况下不能用 -git 正则表达式

操作系统

## 进程、线程、协程

* POSIX线程遵守共享内存模型，此模型各线程可以访问一组共享对象。多个并发的线程需要协同访问共享对象。为此该模型引入了以下两个属性来简化程序设计。
* 原子访问：避免线程在访问数据对象时，另一线程正在修改它。
* 内存可见性：一旦线程修改数据对象，其它线程在修改行为发生之后马上能看见此对象的新状态，如图1所示。
* 线程切换的代价：java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。
* 内存模型
  * 内存可见性：当某个线程正在使用对象状态而另一个线程在同时修改该状态，需要确保当一个线程修改了对象状态后，其他线程能够立即看到发生的状态变化。 由于线程之间的交互都发生在主内存中，但对于变量的修改又发生在自己的工作内存中，经常会造成读写共享变量的错误，我们也叫可见性错误。

## 并发控制与锁

* 悲观锁
* 每次拿数据的时候上锁，其他线程阻塞，拿完释放
  * 其他线程失败，怎么处理
* 适用场景：写多读少（冲突多）
* 机制

```text
- 悲观锁代表 Synchronized 关键字。
```

```text
- Synchronized 关键字实现方法。
```

* 乐观锁
* 拿数据的时候不上锁，更新的时候会判断数据在此期间有没有被更新
* 适用场景：读多写少（冲突少）
* 版本号机制

```text
- 流程
```

```text
  - 在数据表中添加版本号字段
```

```text
  - 读数据的同时读取版本号
```

```text
  - 更新时带上版本号条件，匹配则更新
```

```text
  - 不匹配，怎么处理？
```

* CAS

```text
- 流程
```

```text
  - 需要读写的内存值 V，进行比较的值 A，拟写入的新值 B
```

```text
  - 比较和替换是一个原子操作：当 V 等于 A，更新为 B
```

```text
  - 如果不匹配，怎么处理？自旋？
```

```text
- CAS 是如何保证原子操作的。
```

```text
- 优点
```

```text
  - 基于硬件实现，不需要切换用户态内核态，不需要切换线程
```

```text
  - 性能较高
```

```text
- 缺点
```

```text
  - ABA问题：值被另外一个线程改过又改回来，会被认为是没有修改过
```

```text
  - CAS 带来的循环时间长开销大问题。
```

```text
  - CAS 带来的只能保证一个共享变量的原子操作问题。
```

* AQS
* 乐观锁优点
* 乐观锁缺点
* AtomticXXX 实现的原理。
* volatile 关键字。
* volatile 关键字不能保证原子操作的原因。
* 关于 volatile 关键字的讨论。
* 锁的性质
* 可重入锁：一个线程拿到了某个对象的锁，执行不同方法时无需重新拿锁
* 可中断锁：如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。
* 公平锁：公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。
* 读写锁：多个线程之间的读操作不会发生冲突。
* 偏向锁/轻量级锁/重量级锁 升级过程。自旋锁。分段锁。轻量级锁就一定比重量级锁快吗。
* 内存可见性
* 禁止指令重排序的原因。
* happen-before 规则介绍。

## IO 模型

分为阻塞、非阻塞、IO 多路复用。

poll/select/epoll。

​ IO 网络 IO [https://cloud.tencent.com/developer/article/1005481](https://cloud.tencent.com/developer/article/1005481) 网络 IO 的基本阶段 等待数据准备好 将数据从内核空间的缓存区拷贝到用户空间进程的缓存区 阻塞和非阻塞是针对第一阶段而言 阻塞：询问之后，一直等到就绪再返回 非阻塞：不管是否就绪，询问之后立即返回 同步和异步是针对全过程而言 异步指的是两个阶段都不能阻塞 linux 中没有异步 IO 的实现 windows 中有 IOCP

IO 多路复用 [https://www.cyhone.com/articles/reunderstanding-of-non-blocking-io/](https://www.cyhone.com/articles/reunderstanding-of-non-blocking-io/) [https://www.zhihu.com/question/23614342](https://www.zhihu.com/question/23614342) [https://www.cnblogs.com/alantu2018/p/8472736.html​](https://www.cnblogs.com/alantu2018/p/8472736.html​) 是用较少成本实现 阻塞发生在监控socket的epoll\_wait调用上，，而不是单独某个socket\_fd上 是同步的 阻塞模式socket为每个IO都开一个线程，那就有大量线程被阻塞 epoll 只需要阻塞一个线程 IO模式 1. 对于监听的 sockfd，最好使用水平触发模式，边缘触发模式会导致高并发情况下，有的客户端会连接不上。如果非要使用边缘触发，可以用 while 来循环 accept\(\)。 2. 对于读写的 connfd，水平触发模式下，阻塞和非阻塞效果都一样，建议设置非阻塞。 3. 对于读写的 connfd，边缘触发模式下，必须使用非阻塞 IO，并要求一次性地完整读写全部数据。 实现 HTTP server：[https://www.jianshu.com/p/b63687f91d0f](https://www.jianshu.com/p/b63687f91d0f) 磁盘 IO 为什么书上说同步非阻塞io在对磁盘io上不起作用？[https://www.zhihu.com/question/52989189](https://www.zhihu.com/question/52989189)

