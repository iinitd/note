# 导论

## 数据流基础

三大现代前端框架的核心都是 Data Driven。

`UI = f(data)`

如果数据不变，那么根据数据来渲染界面就是很自然而然的事情。

因此我们的重点在于，数据发生变化的过程。

* 什么是数据？
* 谁修改了数据？
* 如何修改数据？
* 谁知道数据被修改了？
* 数据修改了之后会发生什么？
* 修改的数据全局一致吗？

### 什么是数据？

数据本质上就是 js 对象。

单例？

mobx？concent？redux？

### 谁修改了数据？

**数据是被回调变化的。**

大致可以分为两类，由界面驱动，非界面驱动。

非界面驱动，其实就是 js 代码驱动，进一步说是 js **异步**代码驱动。例如，定时器回调，网络IO回调，文件IO回调，事件回调等。

界面驱动，比如用户点击按钮，在输入框中输入，这些行为都会被浏览器DOM事件捕捉，从而触发onClick、onChange此类的事件回调。

* 如 React，事件回调由用户自己编写，即由用户自己控制如何处理数据变化。
* 如 Vue，表单数据变化由框架处理，通过自定义指令（v-model）将 html DOM 和 js 数据进行绑定，当 DOM 中数据发生变化，由框架更新 js 中的数据。

### 谁知道数据被修改了？

我们如何监听到 js 对象发生了变化呢？

* 框架提供一个 API，让用户自己声明发生了变化，如 React 中的 setState。
* 框架拦截数据的 setter，使得数据的变化自动告知框架。

js 提供了 defineProperty 和 Proxy。

### 数据变化，然后呢

数据变化，是为了驱动界面更新。因此，框架拿到了变化之后，需要在适当的时间处理这些变化，并更新界面。

React Reconciler。浏览器帧。……待更新。

### 数据变化，全局一致吗

现代前端框架都是组件化的，因此需要保证数据在各个组件中是完全一致的。

最原始的方法，声明一个全局单例的状态树，所有的数据修改都是修改同一个对象，这样每个组件拿到的数据就肯定是一致的。

但这个方法必然存在很多弊端：

* 数据变化历史不可回溯
* 每个组件都能修改整个状态树，如果修改不得当，就会造成不可预知的错误。

### 如何修改数据

immutable？mutable？

## 高级特性

### computed

getter？

