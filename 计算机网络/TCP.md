# TCP

## 三次握手

* 第一次握手： 客户端将含有“同步序列号（`SYN`）”标志位的数据段发送给服务端请求链接；客户端进入SYN_SEND状态。
* 第二次握手：服务器用一个带有“确认应答（`ACK`）”和“同步序列号（`SYN`）”标志位的数据段响应客户端；此时服务器进入SYN_RECV状态。
* 第三次握手：客户端收到数据后，发送一个数据段确认收到服务器的数据段，服务器收到数据确认无误，开始传送实际数据；客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

## 四次挥手

* 第一次挥手：客户端发送一个FIN和一个seq，用来关闭客户端到服务器端的数据传送，客户端进入fin_wait1状态；

* 第二次挥手：服务端收到FIN后，返回一个ACK给客户端，同时，将seq的值 + 1 作为确认序号一并返回（确认序号为收到序号 + 1），服务端进入close_wait状态；

* 第三次挥手：服务端发送FIN和一个值为 n 的seq给客户端，用来关闭服务端的数据传输，服务端进入last_wait状态；

* 第四次挥手：客户端收到 FIN后， 客户端进入time_wait状态，接着发送一个ACK和一个带值为n+1的seq给服务端 (确认序号为收到序号 +1) ，服务端进入close状态，完成四次挥手。

## 为什么是三次握手、四次握手？

因为当服务端收到客户端的`SYN`连接请求报文后，可以直接发送`SYN+ACK`报文。其中`ACK`报文负责响应，`SYN`报文负责同步。但是在关闭连接时，当服务端收到`FIN`报文时，很可能并不会立即关闭`socket`，此时只能先回复一个`ACK`报文，来通知客户端，"你发的`FIN`报文我收到了"。只有等到服务端所有的报文都发送完了，才能发送`FIN`报文，因此不能一起发送。所以需要四步握手。

* 什么是 TIME-WAIT、为什么可以是三次挥手、为什么不能是两次握手、流量控制、滑动窗口、Nagle 算法、糊涂窗口综合症、拥塞控制、慢启动、拥塞避免、快重传、快恢复、长连接 VS 短连接、应用场景是什么。

## 可靠性说明

滑动窗口协议：

A有一个发送缓存，B有一个接收缓存，然后通信。A与B建立连接，B设定自己的接收窗口。在建立会话时，B告知A他的接收窗口是20个字节，A就把自己的发送窗口设置为20个字节。A的发送窗口是由B的接收窗口决定的。

SACK 选择性确认，告诉对端哪一部分缺失了。

流量控制

TCP引入了持续计时器（Persistence timer），当A收到对方的零窗口通知时，就启用该计时器，时间到则发送一个1字节的探测报文，对方会在此时回应自身的接收窗口大小，如果结果仍未0，则重设持续计时器，继续等待。

## 滑动窗口

基于确认重传机制

1. 接收方 ACK 时告知发送方
	- 期望接收到的下一字节的序号n
	- 能够接收的窗口长度 m
2. 发送方收到 ACK
	- 如果 n 不等于已发送的序号 x+1，则继续发送 x+1~x+1+m(?)
	- 如果等于，则发送 n~m+n

## 拥塞控制

拥塞控制主要是四个算法：

1）慢启动；
2）拥塞避免；
3）拥塞发生；
4）快速恢复。


---

https://cloud.tencent.com/developer/article/1591989

timewait：https://zhenbianshu.github.io/2018/12/talk_about_tcp_timewait.html